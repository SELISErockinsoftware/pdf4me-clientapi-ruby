=begin
#DmsApi

#No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)

OpenAPI spec version: v1

Generated by: https://github.com/swagger-api/swagger-codegen.git
Swagger Codegen version: 2.3.0

=end

require 'date'

module Pdf4me

  class OptimizeAction
    # With this property one of the predefined optimization profiles can be set. If a profile is set then all the properties  listed in TPDFOptimizationProfile(table Profile Settings) are set to their respective values.Properties not  listed in this table are left unchanged.  One way of quickly arriving at a specific setting is to first set the Profile and then adapt the configuration by  setting some of the individual properties.
    attr_accessor :profile

    attr_accessor :use_profile

    # Get or set whether redundant objects should be removed. If this property is  set to True, duplicate objects are removed in order to reduce the file size.    {default: false}
    attr_accessor :remove_redundant_objects

    # This property influences two optimizations related to subsetted fonts:  - Subset embedded fonts.  - Merge embedded font programs of different subsets of the same font, granted they can be merged.   <para>  Sub-setting refers to removing those glyphs in a font that are not actually  used in any text contained in the PDF.   </para>{default: false}
    attr_accessor :subset_fonts

    # Get or set whether resources should be optimized. If set, unused resources  such as images, fonts, and color spaces are removed.Also content streams  are re-built.    {default: false}
    attr_accessor :optimize_resources

    # If this option is set, then re-compression of images is forced if an image in the  input PDF has a compression type that differs from the compression types  given in ContinuousCompressions, BitonalCompressions, or IndexedCompressions. Use this option if you want to allow only the given  compression types for images in the output PDF.  {default: false}
    attr_accessor :force_compression_types

    # If set, all images are always recompressed.If not set (default), images are only  recompressed if the resulting image is smaller than the original, i.e.requires  less bytes to store in the file.    {default: false}
    attr_accessor :force_recompression

    # This property is used to enable color complexity reduction of images. (See  also Provided Features for Optimizing Images.)  If enabled then images with device color spaces(DeviceRGB, DeviceCMYK,  or DeviceGray) and indexed images with a device color space as base color  space are analyzed and if possible converted as follows:  - An image with DeviceRGB or DeviceCMYK color space in which all pixels  are gray is converted to a grayscale image with DeviceGray color space.  - An image that contains only black and white pixels is converted into a bitonal image.  - An image in which all the pixels have the same color is down-sampled to one pixel.  Furthermore, images’ masks and soft masks are optimized as follows:  - A soft mask that contains only black and white pixels is converted to a mask.  - A (soft) mask that is opaque is removed.    {default: false}
    attr_accessor :reduce_color_complexity

    # Merge embedded font programs. Font programs can be merged, if they  originate from the same font, e.g.they are of the same type, have the same  name and encoding.Merging of Type1(PostScript) and TrueType fonts is supported.
    attr_accessor :merge_embedded_fonts

    # Get or set the compression types for bi-tonal images.  Several values can be combined.The following values are allowed:  ComprAttemptNone  ComprAttemptRaw  ComprAttemptFlate  ComprAttemptLZW  ComprAttemptGroup3  ComprAttemptGroup4  ComprAttemptSource  ComprAttemptJBIG2  Other values are ignored.   <para>  During optimization, all set compression types are tried and the one resulting in the least memory footprint is taken.  Typically, CCITT Group 4 or JBIG2 is used for bi-tonal compression. Due to the simpler algorithm CCITT Group 4 has  the advantage of being faster. JBIG2 can achieve compression ratios that are up to twice as high as CCITT Group 4  at the cost of longer computation time.   </para>{default: ComprAttemptNone}
    attr_accessor :bitonal_compressions

    # Get or set the target resolution in dots per inch (DPI) after re-sampling images  for bi-tonal images.See also ResolutionDPI.    {default: 200}
    attr_accessor :bitonal_resolution_dpi

    # Get or set the threshold resolution in dots per inch (DPI) to selectively activate  re-sampling for bi-tonal images.The value -1 deactivates re-sampling for bitonal images. See also ThresholdDPI.    {default: -1}
    attr_accessor :bitonal_threshold_dpi

    # Get or set the option to clip images. When enabled, then invisible parts of images are clipped (cropped).   While this does not affect visual parts of images, it may have a minor visual impact because clipped   images are re-compressed. Pre-blended images are not clipped. Enabling this property will also   enable the OptimizeResources property.                {default: false}
    attr_accessor :clip_images

    # Get or set the compression types to be tried for continuous images, i.e. RGB, CMYK, and grayscale images.  See also TPDFComprAttempt. Several values can be combined with bitwise or operators.  Other values are ignored. During optimization, all set compression types are tried and the one resulting in   the least memory footprint is taken.    {default: ComprAttemptNone}
    attr_accessor :continuous_compressions

    # Get or set whether to linearize the PDF output file, i.e. optimize file for fast web access.   A linearized document has a slightly larger file size than a non-linearized file and provides the following main features:   - When a document is opened in a PDF viewer of a web browser, the first page can be viewed without downloading the entire   PDF file.In contrast, a non-linearized PDF file must be downloaded completely before the first page can be displayed.  - When another page is requested by the user, that page is displayed as quickly as possible and incrementally as   data arrives, without downloading the entire PDF file.   <para>  Signed files cannot be linearizes. So this property must be set to False if a digital signature is applied.   </para>{default: false}
    attr_accessor :linearize

    # Get or set the quality index of lossy compression types. This value ranges   from 1 to 100 and is applied to JPEG and JPEG2000 compression.For  JPEG2000, a quality index of 100 means lossless compression.JPEG compression is always lossy.    {default: 75}
    attr_accessor :image_quality

    # Get or set the compression types for images that have an indexed (“palette”)  color space.See also TPDFComprAttempt.  Several values can be combined with bitwise or operators.The following values are allowed:  - ComprAttemptNone  - ComprAttemptRaw  - ComprAttemptFlate  - ComprAttemptLZW  - ComprAttemptSource  Other values are ignored.   <para>  During optimization, all set compression types are tried and the one resulting in the least memory footprint is taken.   </para>{default: ComprAttemptFlate}
    attr_accessor :indexed_compressions

    # This option enables or disables dithering when down-sampling bi-tonal images.  The only values supported are eDitherNone and eDitherFloydSteinberg.  Some bi-tonal images try to evoke the impression of different levels of gray   by randomly setting pixels to black.If dithering is applied during downsampling    then the gray levels of such images are preserved better.If dithering is switched    off then lines (e.g.text glyphs) are preserved better.      {default: DitherNone}
    attr_accessor :dithering_mode

    # Get or set the target resolution in dots per inch (DPI) after re-sampling images  for color images.See also ResolutionDPI.    {default: 150}
    attr_accessor :color_resolution_dpi

    # Get or set the threshold resolution in dots per inch (DPI) to selectively activate  re-sampling for color images.The value -1 deactivates re-sampling for color  images. See also ThresholdDPI.    {default: -1}
    attr_accessor :color_threshold_dpi

    # Get or set target resolution in dots per inch (DPI) after re-sampling images  for monochrome images.See also ResolutionDPI.    {default: 150}
    attr_accessor :monochrome_resolution_dpi

    # Get or set the threshold resolution in dots per inch (DPI) to selectively activate  re-sampling for monochrome images.The value -1 deactivates re-sampling  for monochrome images. See also ThresholdDPI.    {default: -1}
    attr_accessor :monochrome_threshold_dpi

    # Get or set the resolution in DPI (dots per inch) after re-sampling images.  This property affects all three image compression types(BitonalResolutionDPI, ColorResolutionDPI, MonochromeResolutionDPI).  A typical value for the resolution when optimizing for the web is 150 DPI.For  printing typically no re-sampling is applied(see property ThresholdDPI).  Pre-blended images, images with a color key mask, mask, and soft mask images are not re-sampled.  When getting ResolutionDPI, the property returns the target resolution in DPI for color images.    {default: Different defaults apply to different image types}
    attr_accessor :resolution_dpi

    # Set the threshold in DPI (dots per inch) to selectively activate re-sampling.  Only images with a resolution above the threshold DPI will be re-sampled.  This property affects all three image compression types(BitonalThresholdDPI, ColorThresholdDPI, MonochromeThresholdDPI). The  value -1 deactivates re-sampling.    {default: -1}
    attr_accessor :threshold_dpi

    #  Get or set the stripping mode. This mode can be configured to remove unneeded data of a PDF document such as Threads, Metadata, the PieceInfo,  the StructTreeRoot entry, embedded Thumbs and the SpiderInfo entry.Also  this mode is used to indicate whether to flatten form fields, links, and other  annotations.Multiple values of TPDFStripType can be combined with the  bitwise or operator.     {default: StripThreads}
    attr_accessor :strip

    #  Set a key-value pair in the document info dictionary. Values of predefined keys are also stored in the XMP metadata.  Popular entries specified in the PDF Reference 1.7 and accepted by most PDF viewers are \"Title\", \"Author\",  \"Subject\", \"Creator\" (sometimes referred to as Application), and \"Producer\" (sometimes referred to as   PDF Creator).
    attr_accessor :info_entries

    # A signature in a PDF consist of two parts:  a.The invisible digital signature in the PDF.  b.The visual appearance that was attributed to the signature.  Part (a) can be used by a viewing application, to verify that a document has not changed since it has been signed  and report this to the user.Part(b) is merely a “decorative” element on the page without further significance.  When optimizing a PDF, the PDF is altered and hence the digital signature is broken.Therefore, all signatures are removed  , including parts(a) and(b).  When the property FlattenSignatureFields is set to True, then digital signatures(parts (a)) are still removed,  but their visual appearances(parts (b)) are flattened.I.e.the latter are retained and drawn as non-editable graphic  onto the page.  <para>  Note: The resulting PDF can be misleading as it visually appears to be signed,  but it has no digital signature and hence, a viewer application does not report any  broken signature.In most cases, such a behavior is undesirable</para>
    attr_accessor :flatten_signature_fields

    attr_accessor :custom_properties

    class EnumAttributeValidator
      attr_reader :datatype
      attr_reader :allowable_values

      def initialize(datatype, allowable_values)
        @allowable_values = allowable_values.map do |value|
          case datatype.to_s
          when /Integer/i
            value.to_i
          when /Float/i
            value.to_f
          else
            value
          end
        end
      end

      def valid?(value)
        !value || allowable_values.include?(value)
      end
    end

    # Attribute mapping from ruby-style variable name to JSON key.
    def self.attribute_map
      {
        :'profile' => :'profile',
        :'use_profile' => :'useProfile',
        :'remove_redundant_objects' => :'removeRedundantObjects',
        :'subset_fonts' => :'subsetFonts',
        :'optimize_resources' => :'optimizeResources',
        :'force_compression_types' => :'forceCompressionTypes',
        :'force_recompression' => :'forceRecompression',
        :'reduce_color_complexity' => :'reduceColorComplexity',
        :'merge_embedded_fonts' => :'mergeEmbeddedFonts',
        :'bitonal_compressions' => :'bitonalCompressions',
        :'bitonal_resolution_dpi' => :'bitonalResolutionDPI',
        :'bitonal_threshold_dpi' => :'bitonalThresholdDPI',
        :'clip_images' => :'clipImages',
        :'continuous_compressions' => :'continuousCompressions',
        :'linearize' => :'linearize',
        :'image_quality' => :'imageQuality',
        :'indexed_compressions' => :'indexedCompressions',
        :'dithering_mode' => :'ditheringMode',
        :'color_resolution_dpi' => :'colorResolutionDPI',
        :'color_threshold_dpi' => :'colorThresholdDPI',
        :'monochrome_resolution_dpi' => :'monochromeResolutionDPI',
        :'monochrome_threshold_dpi' => :'monochromeThresholdDPI',
        :'resolution_dpi' => :'resolutionDPI',
        :'threshold_dpi' => :'thresholdDPI',
        :'strip' => :'strip',
        :'info_entries' => :'infoEntries',
        :'flatten_signature_fields' => :'flattenSignatureFields',
        :'custom_properties' => :'customProperties'
      }
    end

    # Attribute type mapping.
    def self.swagger_types
      {
        :'profile' => :'String',
        :'use_profile' => :'BOOLEAN',
        :'remove_redundant_objects' => :'BOOLEAN',
        :'subset_fonts' => :'BOOLEAN',
        :'optimize_resources' => :'BOOLEAN',
        :'force_compression_types' => :'BOOLEAN',
        :'force_recompression' => :'BOOLEAN',
        :'reduce_color_complexity' => :'BOOLEAN',
        :'merge_embedded_fonts' => :'BOOLEAN',
        :'bitonal_compressions' => :'Array<String>',
        :'bitonal_resolution_dpi' => :'Float',
        :'bitonal_threshold_dpi' => :'Float',
        :'clip_images' => :'BOOLEAN',
        :'continuous_compressions' => :'Array<String>',
        :'linearize' => :'BOOLEAN',
        :'image_quality' => :'Integer',
        :'indexed_compressions' => :'Array<String>',
        :'dithering_mode' => :'String',
        :'color_resolution_dpi' => :'Float',
        :'color_threshold_dpi' => :'Float',
        :'monochrome_resolution_dpi' => :'Float',
        :'monochrome_threshold_dpi' => :'Float',
        :'resolution_dpi' => :'Integer',
        :'threshold_dpi' => :'Integer',
        :'strip' => :'Array<String>',
        :'info_entries' => :'Array<KeyValuePairStringString>',
        :'flatten_signature_fields' => :'BOOLEAN',
        :'custom_properties' => :'Array<KeyValuePairStringString>'
      }
    end

    # Initializes the object
    # @param [Hash] attributes Model attributes in the form of hash
    def initialize(attributes = {})
      return unless attributes.is_a?(Hash)

      # convert string to symbol for hash key
      attributes = attributes.each_with_object({}){|(k,v), h| h[k.to_sym] = v}

      if attributes.has_key?(:'profile')
        self.profile = attributes[:'profile']
      end

      if attributes.has_key?(:'useProfile')
        self.use_profile = attributes[:'useProfile']
      end

      if attributes.has_key?(:'removeRedundantObjects')
        self.remove_redundant_objects = attributes[:'removeRedundantObjects']
      end

      if attributes.has_key?(:'subsetFonts')
        self.subset_fonts = attributes[:'subsetFonts']
      end

      if attributes.has_key?(:'optimizeResources')
        self.optimize_resources = attributes[:'optimizeResources']
      end

      if attributes.has_key?(:'forceCompressionTypes')
        self.force_compression_types = attributes[:'forceCompressionTypes']
      end

      if attributes.has_key?(:'forceRecompression')
        self.force_recompression = attributes[:'forceRecompression']
      end

      if attributes.has_key?(:'reduceColorComplexity')
        self.reduce_color_complexity = attributes[:'reduceColorComplexity']
      end

      if attributes.has_key?(:'mergeEmbeddedFonts')
        self.merge_embedded_fonts = attributes[:'mergeEmbeddedFonts']
      end

      if attributes.has_key?(:'bitonalCompressions')
        if (value = attributes[:'bitonalCompressions']).is_a?(Array)
          self.bitonal_compressions = value
        end
      end

      if attributes.has_key?(:'bitonalResolutionDPI')
        self.bitonal_resolution_dpi = attributes[:'bitonalResolutionDPI']
      end

      if attributes.has_key?(:'bitonalThresholdDPI')
        self.bitonal_threshold_dpi = attributes[:'bitonalThresholdDPI']
      end

      if attributes.has_key?(:'clipImages')
        self.clip_images = attributes[:'clipImages']
      end

      if attributes.has_key?(:'continuousCompressions')
        if (value = attributes[:'continuousCompressions']).is_a?(Array)
          self.continuous_compressions = value
        end
      end

      if attributes.has_key?(:'linearize')
        self.linearize = attributes[:'linearize']
      end

      if attributes.has_key?(:'imageQuality')
        self.image_quality = attributes[:'imageQuality']
      end

      if attributes.has_key?(:'indexedCompressions')
        if (value = attributes[:'indexedCompressions']).is_a?(Array)
          self.indexed_compressions = value
        end
      end

      if attributes.has_key?(:'ditheringMode')
        self.dithering_mode = attributes[:'ditheringMode']
      end

      if attributes.has_key?(:'colorResolutionDPI')
        self.color_resolution_dpi = attributes[:'colorResolutionDPI']
      end

      if attributes.has_key?(:'colorThresholdDPI')
        self.color_threshold_dpi = attributes[:'colorThresholdDPI']
      end

      if attributes.has_key?(:'monochromeResolutionDPI')
        self.monochrome_resolution_dpi = attributes[:'monochromeResolutionDPI']
      end

      if attributes.has_key?(:'monochromeThresholdDPI')
        self.monochrome_threshold_dpi = attributes[:'monochromeThresholdDPI']
      end

      if attributes.has_key?(:'resolutionDPI')
        self.resolution_dpi = attributes[:'resolutionDPI']
      end

      if attributes.has_key?(:'thresholdDPI')
        self.threshold_dpi = attributes[:'thresholdDPI']
      end

      if attributes.has_key?(:'strip')
        if (value = attributes[:'strip']).is_a?(Array)
          self.strip = value
        end
      end

      if attributes.has_key?(:'infoEntries')
        if (value = attributes[:'infoEntries']).is_a?(Array)
          self.info_entries = value
        end
      end

      if attributes.has_key?(:'flattenSignatureFields')
        self.flatten_signature_fields = attributes[:'flattenSignatureFields']
      end

      if attributes.has_key?(:'customProperties')
        if (value = attributes[:'customProperties']).is_a?(Array)
          self.custom_properties = value
        end
      end

    end

    # Show invalid properties with the reasons. Usually used together with valid?
    # @return Array for valid properties with the reasons
    def list_invalid_properties
      invalid_properties = Array.new
      return invalid_properties
    end

    # Check to see if the all the properties in the model are valid
    # @return true if the model is valid
    def valid?
      profile_validator = EnumAttributeValidator.new('String', ["default", "web", "print", "max"])
      return false unless profile_validator.valid?(@profile)
      dithering_mode_validator = EnumAttributeValidator.new('String', ["none", "floydSteinberg", "halftone", "pattern", "g3Optimized", "g4Optimized", "atkinson"])
      return false unless dithering_mode_validator.valid?(@dithering_mode)
      return true
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] profile Object to be assigned
    def profile=(profile)
      validator = EnumAttributeValidator.new('String', ["default", "web", "print", "max"])
      unless validator.valid?(profile)
        fail ArgumentError, "invalid value for 'profile', must be one of #{validator.allowable_values}."
      end
      @profile = profile
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] dithering_mode Object to be assigned
    def dithering_mode=(dithering_mode)
      validator = EnumAttributeValidator.new('String', ["none", "floydSteinberg", "halftone", "pattern", "g3Optimized", "g4Optimized", "atkinson"])
      unless validator.valid?(dithering_mode)
        fail ArgumentError, "invalid value for 'dithering_mode', must be one of #{validator.allowable_values}."
      end
      @dithering_mode = dithering_mode
    end

    # Checks equality by comparing each attribute.
    # @param [Object] Object to be compared
    def ==(o)
      return true if self.equal?(o)
      self.class == o.class &&
          profile == o.profile &&
          use_profile == o.use_profile &&
          remove_redundant_objects == o.remove_redundant_objects &&
          subset_fonts == o.subset_fonts &&
          optimize_resources == o.optimize_resources &&
          force_compression_types == o.force_compression_types &&
          force_recompression == o.force_recompression &&
          reduce_color_complexity == o.reduce_color_complexity &&
          merge_embedded_fonts == o.merge_embedded_fonts &&
          bitonal_compressions == o.bitonal_compressions &&
          bitonal_resolution_dpi == o.bitonal_resolution_dpi &&
          bitonal_threshold_dpi == o.bitonal_threshold_dpi &&
          clip_images == o.clip_images &&
          continuous_compressions == o.continuous_compressions &&
          linearize == o.linearize &&
          image_quality == o.image_quality &&
          indexed_compressions == o.indexed_compressions &&
          dithering_mode == o.dithering_mode &&
          color_resolution_dpi == o.color_resolution_dpi &&
          color_threshold_dpi == o.color_threshold_dpi &&
          monochrome_resolution_dpi == o.monochrome_resolution_dpi &&
          monochrome_threshold_dpi == o.monochrome_threshold_dpi &&
          resolution_dpi == o.resolution_dpi &&
          threshold_dpi == o.threshold_dpi &&
          strip == o.strip &&
          info_entries == o.info_entries &&
          flatten_signature_fields == o.flatten_signature_fields &&
          custom_properties == o.custom_properties
    end

    # @see the `==` method
    # @param [Object] Object to be compared
    def eql?(o)
      self == o
    end

    # Calculates hash code according to all attributes.
    # @return [Fixnum] Hash code
    def hash
      [profile, use_profile, remove_redundant_objects, subset_fonts, optimize_resources, force_compression_types, force_recompression, reduce_color_complexity, merge_embedded_fonts, bitonal_compressions, bitonal_resolution_dpi, bitonal_threshold_dpi, clip_images, continuous_compressions, linearize, image_quality, indexed_compressions, dithering_mode, color_resolution_dpi, color_threshold_dpi, monochrome_resolution_dpi, monochrome_threshold_dpi, resolution_dpi, threshold_dpi, strip, info_entries, flatten_signature_fields, custom_properties].hash
    end

    # Builds the object from hash
    # @param [Hash] attributes Model attributes in the form of hash
    # @return [Object] Returns the model itself
    def build_from_hash(attributes)
      return nil unless attributes.is_a?(Hash)
      self.class.swagger_types.each_pair do |key, type|
        if type =~ /\AArray<(.*)>/i
          # check to ensure the input is an array given that the the attribute
          # is documented as an array but the input is not
          if attributes[self.class.attribute_map[key]].is_a?(Array)
            self.send("#{key}=", attributes[self.class.attribute_map[key]].map{ |v| _deserialize($1, v) } )
          end
        elsif !attributes[self.class.attribute_map[key]].nil?
          self.send("#{key}=", _deserialize(type, attributes[self.class.attribute_map[key]]))
        end # or else data not found in attributes(hash), not an issue as the data can be optional
      end

      self
    end

    # Deserializes the data based on type
    # @param string type Data type
    # @param string value Value to be deserialized
    # @return [Object] Deserialized data
    def _deserialize(type, value)
      case type.to_sym
      when :DateTime
        DateTime.parse(value)
      when :Date
        Date.parse(value)
      when :String
        value.to_s
      when :Integer
        value.to_i
      when :Float
        value.to_f
      when :BOOLEAN
        if value.to_s =~ /\A(true|t|yes|y|1)\z/i
          true
        else
          false
        end
      when :Object
        # generic object (usually a Hash), return directly
        value
      when /\AArray<(?<inner_type>.+)>\z/
        inner_type = Regexp.last_match[:inner_type]
        value.map { |v| _deserialize(inner_type, v) }
      when /\AHash<(?<k_type>.+?), (?<v_type>.+)>\z/
        k_type = Regexp.last_match[:k_type]
        v_type = Regexp.last_match[:v_type]
        {}.tap do |hash|
          value.each do |k, v|
            hash[_deserialize(k_type, k)] = _deserialize(v_type, v)
          end
        end
      else # model
        temp_model = Pdf4me.const_get(type).new
        temp_model.build_from_hash(value)
      end
    end

    # Returns the string representation of the object
    # @return [String] String presentation of the object
    def to_s
      to_hash.to_s
    end

    # to_body is an alias to to_hash (backward compatibility)
    # @return [Hash] Returns the object in the form of hash
    def to_body
      to_hash
    end

    # Returns the object in the form of hash
    # @return [Hash] Returns the object in the form of hash
    def to_hash
      hash = {}
      self.class.attribute_map.each_pair do |attr, param|
        value = self.send(attr)
        next if value.nil?
        hash[param] = _to_hash(value)
      end
      hash
    end

    # Outputs non-array value in the form of hash
    # For object, use to_hash. Otherwise, just return the value
    # @param [Object] value Any valid value
    # @return [Hash] Returns the value in the form of hash
    def _to_hash(value)
      if value.is_a?(Array)
        value.compact.map{ |v| _to_hash(v) }
      elsif value.is_a?(Hash)
        {}.tap do |hash|
          value.each { |k, v| hash[k] = _to_hash(v) }
        end
      elsif value.respond_to? :to_hash
        value.to_hash
      else
        value
      end
    end

  end

end
