=begin
#DmsApi

#No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)

OpenAPI spec version: v1

Generated by: https://github.com/swagger-api/swagger-codegen.git
Swagger Codegen version: 2.3.0

=end

require 'date'

module Pdf4me

  class ImageAction
    # Set the Pages wo apply the convertion.    {default: PageSelection.All}
    attr_accessor :page_selection

    # Set or get the center mode. When set to True, the document is horizontally and vertically centered on the page.  When set to False, the document is printed to the upper left corner of the page.    {default: false}
    attr_accessor :center

    # set the fit page mode. If set to True, the page is scaled to fit the image (in either width or height). If set to  False, the page is rendered with its true size.  {default: true}
    attr_accessor :fit_page

    # Get or set the color depth. Bi-tonal: 1, gray scale: 8, RGB true color: 24, CMYK: 32.    {default: 24}
    attr_accessor :bits_per_pixel

    # Set the threshold for converting from gray to bi-tonal when Dithering is eDitherNone. Value must be in  the range of 0 to 255.    {default: 181}
    attr_accessor :bilevel_threshold

    attr_accessor :width_pixel

    attr_accessor :height_pixel

    attr_accessor :width_point

    attr_accessor :height_point

    # Set a specific rendering option.
    attr_accessor :render_options

    # Set the rotation mode of the page.    Attribute: Set the rotation to the viewing rotation attribute of the PDF page, i.e. rendering the  page with the same rotation as it is displayed in a PDF viewer.    {default: Attribute}
    attr_accessor :rotate_mode

    # If True a uniform up- or down-scaling is applied, i.e. the output image has the same ratio of width to height as the  input file and its size will fit into the defined dimensions, given by SetBitmapDimensions.    {default: true}
    attr_accessor :preserve_aspect_ratio

    # Set the quality index of lossy compression types. This value ranges from 1 to 100 and is applied to JPEG and  JPEG2000 compression.For JPEG2000, a quality index of 100 means lossless compression.JPEG compression is  always lossy.    {default: 80}
    attr_accessor :image_quality

    # Set the Color Management System (CMS) Engine.     {default: 80}
    attr_accessor :cms_engine

    # Set the Color Management System (CMS) Engine.     {default: 80}
    attr_accessor :custom_cms_config

    # Set the dithering algorithm.Dithering refers to the procedure of simulating colors or grayscales.This is mainly  useful for low color depth (e.g.black and white or indexed) images.  The supported values for TPDFDithering are listed in the corresponding enumeration.  {default: DitherFloydSteinberg}
    attr_accessor :dithering

    # <p>              Get or set the resolution of the image in DPI (dots per inch).              Set Both the resolutions for the x- and y-axis are set to the same value.              </p>  <p>              Setting DPI is redundant to setting the specialized properties XDPI and YDPI.              </p>  {default: 150}
    attr_accessor :dpi

    # Set the bit fill order.  MSB (Most significant bit) or LSB (Least significant bit) first.    {default: MostSignificantBit}
    attr_accessor :fill_order

    # <p>              This property is used to enable and parameterize super-sampling, a technique to initially render the image at a              higher resolution and then sample it down to the target resolution.As a result of that process the final image              appears smoother, i.e.anti-aliased.              </p>  <p>              Applying super-sampling improves the image quality when rendering at low target resolutions(72 DPI or less); the              higher the target resolution the less the visual impact.              This property requires memory and CPU time quadratically to the ratio, therefore only small values, such as 2 or 3              should be used.              </p>  <p>              If a too high value (in combination with the original image size) is set, it is ignored.              </p>  {default: 1}
    attr_accessor :filter_ratio

    # Set output Type for image file.
    attr_accessor :image_extension

    # Set color space of the output image, see enumeration TPDFColorSpace.  For black white bi-tonal images, a gray color space must be selected    {default: ColorRGB}
    attr_accessor :color_space

    # Get or set the compression type of TIFF images. For any other image format, the compression is automatically  defined by the file extension(the file name).  The supported values for TPDFCompression are listed in the corresponding enumeration.                {default: ComprLZW}
    attr_accessor :compression

    attr_accessor :custom_properties

    class EnumAttributeValidator
      attr_reader :datatype
      attr_reader :allowable_values

      def initialize(datatype, allowable_values)
        @allowable_values = allowable_values.map do |value|
          case datatype.to_s
          when /Integer/i
            value.to_i
          when /Float/i
            value.to_f
          else
            value
          end
        end
      end

      def valid?(value)
        !value || allowable_values.include?(value)
      end
    end

    # Attribute mapping from ruby-style variable name to JSON key.
    def self.attribute_map
      {
        :'page_selection' => :'pageSelection',
        :'center' => :'center',
        :'fit_page' => :'fitPage',
        :'bits_per_pixel' => :'bitsPerPixel',
        :'bilevel_threshold' => :'bilevelThreshold',
        :'width_pixel' => :'widthPixel',
        :'height_pixel' => :'heightPixel',
        :'width_point' => :'widthPoint',
        :'height_point' => :'heightPoint',
        :'render_options' => :'renderOptions',
        :'rotate_mode' => :'rotateMode',
        :'preserve_aspect_ratio' => :'preserveAspectRatio',
        :'image_quality' => :'imageQuality',
        :'cms_engine' => :'cmsEngine',
        :'custom_cms_config' => :'customCMSConfig',
        :'dithering' => :'dithering',
        :'dpi' => :'dpi',
        :'fill_order' => :'fillOrder',
        :'filter_ratio' => :'filterRatio',
        :'image_extension' => :'imageExtension',
        :'color_space' => :'colorSpace',
        :'compression' => :'compression',
        :'custom_properties' => :'customProperties'
      }
    end

    # Attribute type mapping.
    def self.swagger_types
      {
        :'page_selection' => :'PageSelection',
        :'center' => :'BOOLEAN',
        :'fit_page' => :'BOOLEAN',
        :'bits_per_pixel' => :'Integer',
        :'bilevel_threshold' => :'Integer',
        :'width_pixel' => :'Integer',
        :'height_pixel' => :'Integer',
        :'width_point' => :'Integer',
        :'height_point' => :'Integer',
        :'render_options' => :'Array<String>',
        :'rotate_mode' => :'String',
        :'preserve_aspect_ratio' => :'BOOLEAN',
        :'image_quality' => :'Integer',
        :'cms_engine' => :'String',
        :'custom_cms_config' => :'CustomCMSConfig',
        :'dithering' => :'String',
        :'dpi' => :'Integer',
        :'fill_order' => :'String',
        :'filter_ratio' => :'Integer',
        :'image_extension' => :'String',
        :'color_space' => :'String',
        :'compression' => :'String',
        :'custom_properties' => :'Array<KeyValuePairStringString>'
      }
    end

    # Initializes the object
    # @param [Hash] attributes Model attributes in the form of hash
    def initialize(attributes = {})
      return unless attributes.is_a?(Hash)

      # convert string to symbol for hash key
      attributes = attributes.each_with_object({}){|(k,v), h| h[k.to_sym] = v}

      if attributes.has_key?(:'pageSelection')
        self.page_selection = attributes[:'pageSelection']
      end

      if attributes.has_key?(:'center')
        self.center = attributes[:'center']
      end

      if attributes.has_key?(:'fitPage')
        self.fit_page = attributes[:'fitPage']
      end

      if attributes.has_key?(:'bitsPerPixel')
        self.bits_per_pixel = attributes[:'bitsPerPixel']
      end

      if attributes.has_key?(:'bilevelThreshold')
        self.bilevel_threshold = attributes[:'bilevelThreshold']
      end

      if attributes.has_key?(:'widthPixel')
        self.width_pixel = attributes[:'widthPixel']
      end

      if attributes.has_key?(:'heightPixel')
        self.height_pixel = attributes[:'heightPixel']
      end

      if attributes.has_key?(:'widthPoint')
        self.width_point = attributes[:'widthPoint']
      end

      if attributes.has_key?(:'heightPoint')
        self.height_point = attributes[:'heightPoint']
      end

      if attributes.has_key?(:'renderOptions')
        if (value = attributes[:'renderOptions']).is_a?(Array)
          self.render_options = value
        end
      end

      if attributes.has_key?(:'rotateMode')
        self.rotate_mode = attributes[:'rotateMode']
      end

      if attributes.has_key?(:'preserveAspectRatio')
        self.preserve_aspect_ratio = attributes[:'preserveAspectRatio']
      end

      if attributes.has_key?(:'imageQuality')
        self.image_quality = attributes[:'imageQuality']
      end

      if attributes.has_key?(:'cmsEngine')
        self.cms_engine = attributes[:'cmsEngine']
      end

      if attributes.has_key?(:'customCMSConfig')
        self.custom_cms_config = attributes[:'customCMSConfig']
      end

      if attributes.has_key?(:'dithering')
        self.dithering = attributes[:'dithering']
      end

      if attributes.has_key?(:'dpi')
        self.dpi = attributes[:'dpi']
      end

      if attributes.has_key?(:'fillOrder')
        self.fill_order = attributes[:'fillOrder']
      end

      if attributes.has_key?(:'filterRatio')
        self.filter_ratio = attributes[:'filterRatio']
      end

      if attributes.has_key?(:'imageExtension')
        self.image_extension = attributes[:'imageExtension']
      end

      if attributes.has_key?(:'colorSpace')
        self.color_space = attributes[:'colorSpace']
      end

      if attributes.has_key?(:'compression')
        self.compression = attributes[:'compression']
      end

      if attributes.has_key?(:'customProperties')
        if (value = attributes[:'customProperties']).is_a?(Array)
          self.custom_properties = value
        end
      end

    end

    # Show invalid properties with the reasons. Usually used together with valid?
    # @return Array for valid properties with the reasons
    def list_invalid_properties
      invalid_properties = Array.new
      return invalid_properties
    end

    # Check to see if the all the properties in the model are valid
    # @return true if the model is valid
    def valid?
      rotate_mode_validator = EnumAttributeValidator.new('String', ["none", "attribute", "portrait", "landscape"])
      return false unless rotate_mode_validator.valid?(@rotate_mode)
      cms_engine_validator = EnumAttributeValidator.new('String', ["none", "neugebauer", "lcms", "customCMS"])
      return false unless cms_engine_validator.valid?(@cms_engine)
      dithering_validator = EnumAttributeValidator.new('String', ["none", "floydSteinberg", "halftone", "pattern", "g3Optimized", "g4Optimized", "atkinson"])
      return false unless dithering_validator.valid?(@dithering)
      fill_order_validator = EnumAttributeValidator.new('String', ["mSB", "lSB"])
      return false unless fill_order_validator.valid?(@fill_order)
      image_extension_validator = EnumAttributeValidator.new('String', ["jpg", "jpeg", "bmp", "gif", "jb2", "jp2", "jpf", "jpx", "png", "tif", "tiff"])
      return false unless image_extension_validator.valid?(@image_extension)
      color_space_validator = EnumAttributeValidator.new('String', ["rGB", "rGBA", "gray", "grayA", "cMYK", "yCbCr", "yCbCrK", "palette", "lAB", "cMYK_Konly", "cMYKA"])
      return false unless color_space_validator.valid?(@color_space)
      compression_validator = EnumAttributeValidator.new('String', ["lZW", "jPEG", "flate", "raw", "group3", "group3_2D", "group4", "jBIG2", "jPEG2000", "tIFFJPEG"])
      return false unless compression_validator.valid?(@compression)
      return true
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] rotate_mode Object to be assigned
    def rotate_mode=(rotate_mode)
      validator = EnumAttributeValidator.new('String', ["none", "attribute", "portrait", "landscape"])
      unless validator.valid?(rotate_mode)
        fail ArgumentError, "invalid value for 'rotate_mode', must be one of #{validator.allowable_values}."
      end
      @rotate_mode = rotate_mode
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] cms_engine Object to be assigned
    def cms_engine=(cms_engine)
      validator = EnumAttributeValidator.new('String', ["none", "neugebauer", "lcms", "customCMS"])
      unless validator.valid?(cms_engine)
        fail ArgumentError, "invalid value for 'cms_engine', must be one of #{validator.allowable_values}."
      end
      @cms_engine = cms_engine
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] dithering Object to be assigned
    def dithering=(dithering)
      validator = EnumAttributeValidator.new('String', ["none", "floydSteinberg", "halftone", "pattern", "g3Optimized", "g4Optimized", "atkinson"])
      unless validator.valid?(dithering)
        fail ArgumentError, "invalid value for 'dithering', must be one of #{validator.allowable_values}."
      end
      @dithering = dithering
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] fill_order Object to be assigned
    def fill_order=(fill_order)
      validator = EnumAttributeValidator.new('String', ["mSB", "lSB"])
      unless validator.valid?(fill_order)
        fail ArgumentError, "invalid value for 'fill_order', must be one of #{validator.allowable_values}."
      end
      @fill_order = fill_order
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] image_extension Object to be assigned
    def image_extension=(image_extension)
      validator = EnumAttributeValidator.new('String', ["jpg", "jpeg", "bmp", "gif", "jb2", "jp2", "jpf", "jpx", "png", "tif", "tiff"])
      unless validator.valid?(image_extension)
        fail ArgumentError, "invalid value for 'image_extension', must be one of #{validator.allowable_values}."
      end
      @image_extension = image_extension
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] color_space Object to be assigned
    def color_space=(color_space)
      validator = EnumAttributeValidator.new('String', ["rGB", "rGBA", "gray", "grayA", "cMYK", "yCbCr", "yCbCrK", "palette", "lAB", "cMYK_Konly", "cMYKA"])
      unless validator.valid?(color_space)
        fail ArgumentError, "invalid value for 'color_space', must be one of #{validator.allowable_values}."
      end
      @color_space = color_space
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] compression Object to be assigned
    def compression=(compression)
      validator = EnumAttributeValidator.new('String', ["lZW", "jPEG", "flate", "raw", "group3", "group3_2D", "group4", "jBIG2", "jPEG2000", "tIFFJPEG"])
      unless validator.valid?(compression)
        fail ArgumentError, "invalid value for 'compression', must be one of #{validator.allowable_values}."
      end
      @compression = compression
    end

    # Checks equality by comparing each attribute.
    # @param [Object] Object to be compared
    def ==(o)
      return true if self.equal?(o)
      self.class == o.class &&
          page_selection == o.page_selection &&
          center == o.center &&
          fit_page == o.fit_page &&
          bits_per_pixel == o.bits_per_pixel &&
          bilevel_threshold == o.bilevel_threshold &&
          width_pixel == o.width_pixel &&
          height_pixel == o.height_pixel &&
          width_point == o.width_point &&
          height_point == o.height_point &&
          render_options == o.render_options &&
          rotate_mode == o.rotate_mode &&
          preserve_aspect_ratio == o.preserve_aspect_ratio &&
          image_quality == o.image_quality &&
          cms_engine == o.cms_engine &&
          custom_cms_config == o.custom_cms_config &&
          dithering == o.dithering &&
          dpi == o.dpi &&
          fill_order == o.fill_order &&
          filter_ratio == o.filter_ratio &&
          image_extension == o.image_extension &&
          color_space == o.color_space &&
          compression == o.compression &&
          custom_properties == o.custom_properties
    end

    # @see the `==` method
    # @param [Object] Object to be compared
    def eql?(o)
      self == o
    end

    # Calculates hash code according to all attributes.
    # @return [Fixnum] Hash code
    def hash
      [page_selection, center, fit_page, bits_per_pixel, bilevel_threshold, width_pixel, height_pixel, width_point, height_point, render_options, rotate_mode, preserve_aspect_ratio, image_quality, cms_engine, custom_cms_config, dithering, dpi, fill_order, filter_ratio, image_extension, color_space, compression, custom_properties].hash
    end

    # Builds the object from hash
    # @param [Hash] attributes Model attributes in the form of hash
    # @return [Object] Returns the model itself
    def build_from_hash(attributes)
      return nil unless attributes.is_a?(Hash)
      self.class.swagger_types.each_pair do |key, type|
        if type =~ /\AArray<(.*)>/i
          # check to ensure the input is an array given that the the attribute
          # is documented as an array but the input is not
          if attributes[self.class.attribute_map[key]].is_a?(Array)
            self.send("#{key}=", attributes[self.class.attribute_map[key]].map{ |v| _deserialize($1, v) } )
          end
        elsif !attributes[self.class.attribute_map[key]].nil?
          self.send("#{key}=", _deserialize(type, attributes[self.class.attribute_map[key]]))
        end # or else data not found in attributes(hash), not an issue as the data can be optional
      end

      self
    end

    # Deserializes the data based on type
    # @param string type Data type
    # @param string value Value to be deserialized
    # @return [Object] Deserialized data
    def _deserialize(type, value)
      case type.to_sym
      when :DateTime
        DateTime.parse(value)
      when :Date
        Date.parse(value)
      when :String
        value.to_s
      when :Integer
        value.to_i
      when :Float
        value.to_f
      when :BOOLEAN
        if value.to_s =~ /\A(true|t|yes|y|1)\z/i
          true
        else
          false
        end
      when :Object
        # generic object (usually a Hash), return directly
        value
      when /\AArray<(?<inner_type>.+)>\z/
        inner_type = Regexp.last_match[:inner_type]
        value.map { |v| _deserialize(inner_type, v) }
      when /\AHash<(?<k_type>.+?), (?<v_type>.+)>\z/
        k_type = Regexp.last_match[:k_type]
        v_type = Regexp.last_match[:v_type]
        {}.tap do |hash|
          value.each do |k, v|
            hash[_deserialize(k_type, k)] = _deserialize(v_type, v)
          end
        end
      else # model
        temp_model = Pdf4me.const_get(type).new
        temp_model.build_from_hash(value)
      end
    end

    # Returns the string representation of the object
    # @return [String] String presentation of the object
    def to_s
      to_hash.to_s
    end

    # to_body is an alias to to_hash (backward compatibility)
    # @return [Hash] Returns the object in the form of hash
    def to_body
      to_hash
    end

    # Returns the object in the form of hash
    # @return [Hash] Returns the object in the form of hash
    def to_hash
      hash = {}
      self.class.attribute_map.each_pair do |attr, param|
        value = self.send(attr)
        next if value.nil?
        hash[param] = _to_hash(value)
      end
      hash
    end

    # Outputs non-array value in the form of hash
    # For object, use to_hash. Otherwise, just return the value
    # @param [Object] value Any valid value
    # @return [Hash] Returns the value in the form of hash
    def _to_hash(value)
      if value.is_a?(Array)
        value.compact.map{ |v| _to_hash(v) }
      elsif value.is_a?(Hash)
        {}.tap do |hash|
          value.each { |k, v| hash[k] = _to_hash(v) }
        end
      elsif value.respond_to? :to_hash
        value.to_hash
      else
        value
      end
    end

  end

end
